# Abstract
The program uses a region of **stack** and **heap** for handling various values during run-time.

A variable size of allocating on the stack is decided at the **compile-time**. Conversely, allocating  the variable to using memory allocator such as `malloc` , size will be deciding at the **run-time**.

Assuming a various situation, Both of regions have the potential to **vulnerability** if unexpected exceptions occur without exception handling while a program handling an arbitrary value. 

Understand **memory allocator** and **heap structure** has been an integral part of **heap exploitation**.

In this article, I describe heap's management and manipulating based on *ptmalloc2.*

*ptmalloc2* memory allocator has implemented on *glibc* and depend on the version, implementations are slightly different.  

# Introduction

Basically, fundamental heap structures are not different as much. 

- ptmalloc2(pthread malloc) GNU C Library
- dlmalloc(Doug Lea's Malloc) General-purpose allocator
- TCMalloc(google)
- etc

Among various memory allocators, *ptmalloc2* has these characterizations.

- *ptmalloc2* activating at more than least two memory area at a time to handle multithreaded applications efficiently.
- When multiple threads invoking `malloc` at the same time, heap segment created on each thread and Arena management that area.
- Therefore, each thread can access own heap without interference.

Application's Arena quantity limit is based on number of cores in the present system.

```c
For 32 bit systems:
     Number of arena = 2 * number of cores.
For 64 bit systems:
     Number of arena = 8 * number of cores.
```

# Chunk

The memory space requested by malloc during runtime, that is called a Chunk.

Irrespective of size and allocated and freed, whole chunks are consist of a `malloc_chunk` structure.

```c
struct malloc_chunk {

  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */

  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};
```

`INTERNAL_SIZE_T` and `SIZE_SZ` are equals to `size_t`.

```c
#ifndef INTERNAL_SIZE_T
# define INTERNAL_SIZE_T size_t
#endif
/* The corresponding word size.  */
#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))
```

### prev_size

Store previous chunk's size. This field will be setup when previous chunk is freed.

### size

The size must be a multiple of `2 * SIZE_SZ`.

Heap manager ensures allocation will be 8 bytes aligned on 32 bits system or 16 bytes aligned on 64 bits system. 

Thus, the 3 bits of this field is used for a flag because it's wasted.

- (100)NON_MAIN_ARENA: If present chunk is not belong on main arena this flag will be 1 else is 0.
- (010)IS_MMAPPED: This chunk was allocated with a single call to `mmap` and is not part of a heap at all.
- (001)PREV_INUSE: Previous chunk is in use. if set, the previous chunk is still being used by this application, and thus the `prev_size` field is invalid. some chunks, such as fastbins will have this bit set despite being freed by application. This bit really means that the previous chunk should not be considered a candidate for coalescing.

# References
* https://sourceware.org/glibc/wiki/MallocInternals
